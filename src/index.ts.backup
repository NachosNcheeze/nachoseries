/**
 * NachoSeries - Series Database Builder
 * Aggregates and reconciles book series data from multiple sources
 */

import { initDatabase, getStats, closeDatabase, upsertSeries, upsertSeriesBook, findSeriesByName, getSeriesNeedingVerification, storeSourceData } from './database/db.js';
import { fetchSeries as fetchLibraryThing } from './sources/librarything.js';
import { fetchSeries as fetchOpenLibrary } from './sources/openLibrary.js';
import { fetchSeries as fetchISFDB, browseSeriesByGenre, fetchSeriesById, genreKeywords, discoverSeriesFromAuthors, scanSeriesRange, fetchPopularAuthors, fetchAuthorSeries } from './sources/isfdb.js';
import { checkFlareSolverr } from './sources/flareSolverr.js';
import { compareSources, needsTalpaVerification } from './reconciler/matcher.js';
import { config } from './config.js';
import { knownSeries } from './data/knownSeries.js';

async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || 'status';
  
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘                        NACHOSERIES                             â•‘');
  console.log('â•‘              Series Database Builder v0.1.0                    â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('');
  
  // Initialize database
  initDatabase();
  
  switch (command) {
    case 'status':
      await showStatus();
      break;
      
    case 'test':
      await runTestFetch(args[1]);
      break;
      
    case 'crawl':
      await runCrawl(args[1], args.includes('--save'));
      break;
      
    case 'verify':
      await runVerify();
      break;
      
    case 'discover':
      const discoverLimit = parseInt(args.find(a => a.startsWith('--limit='))?.split('=')[1] || '100');
      await runDiscover(args[1] || 'authors', args.includes('--save'), discoverLimit);
      break;

    case 'save':
      await saveSeriesFromTest(args[1]);
      break;
      
    default:
      console.log('Usage: nachoseries <command>');
      console.log('');
      console.log('Commands:');
      console.log('  status           Show database statistics');
      console.log('  test [series]    Test fetch a specific series');
      console.log('  crawl [genre]    Crawl series for a genre (--save to persist)');
      console.log('  save [series]    Fetch and save a specific series');
      console.log('  verify           Verify existing series data');
      console.log('  discover [mode]  Discover series (modes: authors, scan, seed)');
      console.log('');
      console.log('Options:');
      console.log('  --save           Save discovered series to database');
      console.log('  --limit=N        Limit number of items to process');
      console.log('');
      console.log('Genres: ' + Object.keys(genreKeywords).join(', '));
      break;
  }
  
  closeDatabase();
}

async function showStatus() {
  console.log('ğŸ“Š Database Status');
  console.log('â”€'.repeat(50));
  
  const stats = getStats();
  
  console.log(`Total Series:     ${stats.totalSeries}`);
  console.log(`Total Books:      ${stats.totalBooks}`);
  console.log(`Verified Series:  ${stats.verifiedSeries}`);
  console.log(`Avg Confidence:   ${(stats.avgConfidence * 100).toFixed(1)}%`);
  console.log('');
  console.log('Series by Genre:');
  for (const [genre, count] of Object.entries(stats.seriesByGenre)) {
    console.log(`  ${genre}: ${count}`);
  }
  console.log('');
  console.log('ğŸ”Œ Services Status');
  console.log('â”€'.repeat(50));
  const flareSolverrOk = await checkFlareSolverr();
  console.log(`FlareSolverr:     ${flareSolverrOk ? 'âœ… Online' : 'âŒ Offline'} (${config.flareSolverr.url})`);
  console.log('');
  console.log('ğŸ“‹ Configuration');
  console.log('â”€'.repeat(50));
  console.log(`Genres: ${config.genres.join(', ')}`);
  console.log(`Year Range: ${config.yearRange.start}-${config.yearRange.end}`);
  console.log(`Auto-Accept Threshold: ${config.confidence.autoAccept * 100}%`);
}

async function runTestFetch(seriesName?: string) {
  const name = seriesName || 'The Stormlight Archive';
  
  console.log(`ğŸ” Testing fetch for: "${name}"`);
  console.log('â”€'.repeat(50));
  
  // Fetch from ISFDB (most reliable for speculative fiction)
  console.log('\nğŸ“š ISFDB:');
  const isfdbResult = await fetchISFDB(name);
  
  if (isfdbResult.error) {
    console.log(`  âŒ Error: ${isfdbResult.error}`);
  } else if (isfdbResult.series) {
    console.log(`  âœ… Found ${isfdbResult.series.books.length} books`);
    console.log(`  Author: ${isfdbResult.series.author || 'Unknown'}`);
    for (const book of isfdbResult.series.books.slice(0, 5)) {
      console.log(`    ${book.position || '?'}. ${book.title} (${book.yearPublished || '?'})`);
    }
    if (isfdbResult.series.books.length > 5) {
      console.log(`    ... and ${isfdbResult.series.books.length - 5} more`);
    }
  } else {
    console.log('  âš ï¸ No results');
  }
  
  // Fetch from Open Library
  console.log('\nğŸ“– Open Library:');
  const olResult = await fetchOpenLibrary(name);
  
  if (olResult.error) {
    console.log(`  âŒ Error: ${olResult.error}`);
  } else if (olResult.series) {
    console.log(`  âœ… Found ${olResult.series.books.length} books`);
    console.log(`  Author: ${olResult.series.author || 'Unknown'}`);
    for (const book of olResult.series.books.slice(0, 5)) {
      console.log(`    ${book.position || '?'}. ${book.title}`);
    }
    if (olResult.series.books.length > 5) {
      console.log(`    ... and ${olResult.series.books.length - 5} more`);
    }
  } else {
    console.log('  âš ï¸ No results');
  }
  
  // Optionally try LibraryThing (may not work due to JS requirement)
  console.log('\nğŸ“• LibraryThing (experimental):');
  const ltResult = await fetchLibraryThing(name);
  
  if (ltResult.error) {
    console.log(`  âŒ Error: ${ltResult.error}`);
  } else if (ltResult.series) {
    console.log(`  âœ… Found ${ltResult.series.books.length} books`);
    console.log(`  Author: ${ltResult.series.author || 'Unknown'}`);
    for (const book of ltResult.series.books.slice(0, 5)) {
      console.log(`    ${book.position || '?'}. ${book.title}`);
    }
    if (ltResult.series.books.length > 5) {
      console.log(`    ... and ${ltResult.series.books.length - 5} more`);
    }
  } else {
    console.log('  âš ï¸ No results (site requires JavaScript)');
  }
  
  // Compare ISFDB and Open Library results
  if (isfdbResult.series && olResult.series) {
    console.log('\nâš–ï¸ ISFDB vs Open Library Comparison:');
    const comparison = compareSources(isfdbResult, olResult);
    
    if (comparison) {
      console.log(`  Confidence: ${(comparison.confidence * 100).toFixed(1)}%`);
      console.log(`  Book Count Match: ${comparison.bookCountMatch ? 'âœ…' : 'âŒ'} (${comparison.bookCountA} vs ${comparison.bookCountB})`);
      console.log(`  Title Matches: ${comparison.titleMatches}`);
      console.log(`  Order Match: ${comparison.orderMatch ? 'âœ…' : 'âŒ'}`);
      
      if (comparison.discrepancies.length > 0) {
        console.log('  Discrepancies:');
        for (const d of comparison.discrepancies.slice(0, 5)) {
          console.log(`    - ${d.field}: ${d.valueA} (${d.sourceA}) vs ${d.valueB} (${d.sourceB})`);
        }
        if (comparison.discrepancies.length > 5) {
          console.log(`    ... and ${comparison.discrepancies.length - 5} more`);
        }
      }
      
      if (needsTalpaVerification(comparison)) {
        console.log('  âš ï¸ Would queue for Talpa verification');
      } else if (comparison.confidence >= config.confidence.autoAccept) {
        console.log('  âœ… Would auto-accept');
      } else {
        console.log('  ğŸ” Would need manual review');
      }
    }
  }
  
  // Compare with known data if available
  const known = knownSeries.find(k => k.name.toLowerCase() === name.toLowerCase());
  if (known) {
    console.log('\nğŸ“‹ Known Data Comparison:');
    console.log(`  Expected: ${known.bookCount} books by ${known.author}`);
    
    if (isfdbResult.series) {
      const isfdbDiff = isfdbResult.series.books.length - known.bookCount;
      console.log(`  ISFDB: ${isfdbDiff === 0 ? 'âœ… Exact match' : `${isfdbDiff > 0 ? '+' : ''}${isfdbDiff} books`}`);
    }
    
    if (olResult.series) {
      const olDiff = olResult.series.books.length - known.bookCount;
      console.log(`  Open Library: ${olDiff === 0 ? 'âœ… Exact match' : `${olDiff > 0 ? '+' : ''}${olDiff} books`}`);
    }
    
    if (ltResult.series) {
      const ltDiff = ltResult.series.books.length - known.bookCount;
      console.log(`  LibraryThing: ${ltDiff === 0 ? 'âœ… Exact match' : `${ltDiff > 0 ? '+' : ''}${ltDiff} books`}`);
    }
  }
}

async function runCrawl(genre?: string, saveToDb = false) {
  const targetGenre = genre || config.genres[0];
  
  console.log(`ğŸ”„ Crawling genre: ${targetGenre}`);
  console.log(`ğŸ“ Save to database: ${saveToDb ? 'Yes' : 'No (dry run)'}`);
  console.log('â”€'.repeat(50));
  
  // Check if genre is valid
  if (!genreKeywords[targetGenre]) {
    console.log(`âŒ Unknown genre: ${targetGenre}`);
    console.log(`   Available: ${Object.keys(genreKeywords).join(', ')}`);
    return;
  }
  
  // Discover series for the genre
  console.log(`\nğŸ” Discovering series for "${targetGenre}"...`);
  const seriesList = await browseSeriesByGenre(targetGenre);
  
  console.log(`\nğŸ“Š Found ${seriesList.length} series to process`);
  console.log('â”€'.repeat(50));
  
  let saved = 0;
  let skipped = 0;
  let errors = 0;
  
  for (let i = 0; i < seriesList.length; i++) {
    const seriesRef = seriesList[i];
    const progress = `[${i + 1}/${seriesList.length}]`;
    
    // Check if already in database
    const existing = findSeriesByName(seriesRef.name);
    if (existing) {
      console.log(`${progress} â­ï¸  ${seriesRef.name} (already exists)`);
      skipped++;
      continue;
    }
    
    // Fetch full series data
    console.log(`${progress} ğŸ“¥ Fetching: ${seriesRef.name}`);
    const result = await fetchSeriesById(seriesRef.id);
    
    if (result.error || !result.series) {
      console.log(`${progress} âŒ Error: ${result.error || 'No data'}`);
      errors++;
      continue;
    }
    
    const series = result.series;
    
    // Skip series with no books or too few books
    if (series.books.length < 2) {
      console.log(`${progress} â­ï¸  ${series.name} (only ${series.books.length} book)`);
      skipped++;
      continue;
    }
    
    // Calculate year range
    const years = series.books.map(b => b.yearPublished).filter((y): y is number => y !== undefined);
    const yearStart = years.length > 0 ? Math.min(...years) : undefined;
    const yearEnd = years.length > 0 ? Math.max(...years) : undefined;
    
    console.log(`${progress} âœ… ${series.name} - ${series.books.length} books by ${series.author || 'Unknown'}`);
    
    if (saveToDb) {
      // Save to database
      const seriesId = upsertSeries({
        name: series.name,
        author: series.author,
        genre: targetGenre,
        total_books: series.books.length,
        year_start: yearStart,
        year_end: yearEnd,
        confidence: 0.8,  // ISFDB is generally reliable
        isfdb_id: series.sourceId,
      });
      
      // Save each book
      for (const book of series.books) {
        upsertSeriesBook({
          series_id: seriesId,
          title: book.title,
          position: book.position,
          author: book.author,
          year_published: book.yearPublished,
          confidence: 0.8,
        });
      }
      
      // Store raw source data
      storeSourceData(seriesId, 'isfdb', result.raw, series.books.length);
      
      saved++;
    } else {
      saved++;  // Count as "would be saved" in dry run
    }
  }
  
  console.log('');
  console.log('â”€'.repeat(50));
  console.log('ğŸ“Š Crawl Summary:');
  console.log(`  Genre: ${targetGenre}`);
  console.log(`  Processed: ${seriesList.length} series`);
  console.log(`  ${saveToDb ? 'Saved' : 'Would save'}: ${saved}`);
  console.log(`  Skipped: ${skipped}`);
  console.log(`  Errors: ${errors}`);
  
  if (!saveToDb) {
    console.log('');
    console.log('ğŸ’¡ Run with --save to persist to database');
  }
}

async function saveSeriesFromTest(seriesName?: string) {
  const name = seriesName || 'The Stormlight Archive';
  
  console.log(`ğŸ’¾ Fetching and saving: "${name}"`);
  console.log('â”€'.repeat(50));
  
  // Check if already exists
  const existing = findSeriesByName(name);
  if (existing) {
    console.log(`âš ï¸ Series already exists in database (ID: ${existing.id})`);
    console.log(`   Name: ${existing.name}`);
    console.log(`   Books: ${existing.total_books}`);
    return;
  }
  
  // Fetch from ISFDB
  const result = await fetchISFDB(name);
  
  if (result.error || !result.series) {
    console.log(`âŒ Error fetching series: ${result.error || 'No data'}`);
    return;
  }
  
  const series = result.series;
  console.log(`âœ… Found: ${series.name} - ${series.books.length} books`);
  
  // Calculate year range
  const years = series.books.map(b => b.yearPublished).filter((y): y is number => y !== undefined);
  const yearStart = years.length > 0 ? Math.min(...years) : undefined;
  const yearEnd = years.length > 0 ? Math.max(...years) : undefined;
  
  // Save to database
  const seriesId = upsertSeries({
    name: series.name,
    author: series.author,
    total_books: series.books.length,
    year_start: yearStart,
    year_end: yearEnd,
    confidence: 0.8,
    isfdb_id: series.sourceId,
  });
  
  console.log(`ğŸ“ Saved series with ID: ${seriesId}`);
  
  // Save each book
  for (const book of series.books) {
    upsertSeriesBook({
      series_id: seriesId,
      title: book.title,
      position: book.position,
      author: book.author,
      year_published: book.yearPublished,
      confidence: 0.8,
    });
    console.log(`  ğŸ“– Saved: ${book.position}. ${book.title}`);
  }
  
  // Store raw source data
  storeSourceData(seriesId, 'isfdb', result.raw, series.books.length);
  
  console.log('');
  console.log('âœ… Series saved successfully!');
}

async function runVerify() {
  console.log('âœ… Verifying existing series...');
  console.log('â”€'.repeat(50));
  
  // Get series needing verification
  const toVerify = getSeriesNeedingVerification(10);
  
  if (toVerify.length === 0) {
    console.log('No series need verification!');
    return;
  }
  
  console.log(`Found ${toVerify.length} series needing verification:`);
  console.log('');
  
  for (const series of toVerify) {
    console.log(`ğŸ“‹ ${series.name}`);
    console.log(`   Confidence: ${(series.confidence * 100).toFixed(1)}%`);
    console.log(`   Books: ${series.total_books || '?'}`);
    console.log(`   Author: ${series.author || 'Unknown'}`);
    
    // Fetch fresh data from ISFDB
    if (series.isfdb_id) {
      console.log(`   Refreshing from ISFDB...`);
      const result = await fetchSeriesById(series.isfdb_id);
      
      if (result.series) {
        const freshBooks = result.series.books.length;
        const diff = freshBooks - (series.total_books || 0);
        
        if (diff !== 0) {
          console.log(`   âš ï¸ Book count changed: ${series.total_books} â†’ ${freshBooks} (${diff > 0 ? '+' : ''}${diff})`);
        } else {
          console.log(`   âœ… Book count verified: ${freshBooks}`);
        }
      }
    }
    console.log('');
  }
  
  console.log('â”€'.repeat(50));
  console.log('ğŸ’¡ Full verification with cross-source reconciliation coming soon!');
}

main().catch(console.error);

async function runDiscover(mode: string, saveToDb = false, limit = 100) {
  console.log(`ğŸ” Discovery mode: ${mode}`);
  console.log(`ğŸ“ Save to database: ${saveToDb ? 'Yes' : 'No (dry run)'}`);
  console.log(`ğŸ“Š Limit: ${limit} ${mode === 'authors' ? 'authors' : 'series IDs'}`);
  console.log('â”€'.repeat(50));
  
  let discoveredSeries: Array<{ id: string; name: string; author?: string }> = [];
  
  if (mode === 'authors') {
    // Import the function dynamically since we just added it
    const { discoverSeriesFromAuthors } = await import('./sources/isfdb.js');
    
    console.log('\nğŸ”„ Crawling popular authors for their series...\n');
    
    discoveredSeries = await discoverSeriesFromAuthors(limit, (current, total, author, count) => {
      const progress = `[${current}/${total}]`;
      console.log(`${progress} ${author}: ${count} series`);
    });
  } else if (mode === 'scan') {
    const { scanSeriesRange } = await import('./sources/isfdb.js');
    
    // Start from series ID 1 and scan
    console.log(`\nğŸ”„ Scanning series IDs 1-${limit}...\n`);
    
    discoveredSeries = await scanSeriesRange(1, limit, (current, total, found) => {
      if (current % 100 === 0 || current === total) {
        console.log(`  Progress: ${current}/${total} (found: ${found})`);
      }
    });
  } else if (mode === 'seed') {
    // Import known series from our seed list
    console.log('\nğŸ“‹ Importing known series from seed list...\n');
    
    for (const known of knownSeries) {
      console.log(`  ${known.name} by ${known.author}`);
      discoveredSeries.push({ id: '', name: known.name, author: known.author });
    }
  } else {
    console.log(`âŒ Unknown discovery mode: ${mode}`);
    console.log('   Available modes: authors, scan, seed');
    return;
  }
  
  console.log('');
  console.log('â”€'.repeat(50));
  console.log(`\nğŸ“Š Discovered ${discoveredSeries.length} series\n`);
  
  if (!saveToDb) {
    console.log('Top 20 discovered series:');
    for (const s of discoveredSeries.slice(0, 20)) {
      console.log(`  - ${s.name}${s.author ? ` (${s.author})` : ''}`);
    }
    if (discoveredSeries.length > 20) {
      console.log(`  ... and ${discoveredSeries.length - 20} more`);
    }
    console.log('');
    console.log('ğŸ’¡ Run with --save to fetch full details and persist to database');
    return;
  }
  
  // Fetch and save each series
  console.log('Fetching and saving series details...\n');
  
  let saved = 0;
  let skipped = 0;
  let errors = 0;
  
  for (let i = 0; i < discoveredSeries.length; i++) {
    const seriesRef = discoveredSeries[i];
    const progress = `[${i + 1}/${discoveredSeries.length}]`;
    
    // Check if already in database
    const existing = findSeriesByName(seriesRef.name);
    if (existing) {
      console.log(`${progress} â­ï¸  ${seriesRef.name} (already exists)`);
      skipped++;
      continue;
    }
    
    // Fetch full series data
    let result;
    if (seriesRef.id) {
      result = await fetchSeriesById(seriesRef.id);
    } else {
      // For seed mode, search by name
      result = await fetchISFDB(seriesRef.name);
    }
    
    if (result.error || !result.series) {
      console.log(`${progress} âŒ ${seriesRef.name}: ${result.error || 'No data'}`);
      errors++;
      continue;
    }
    
    const series = result.series;
    
    // Skip series with too few books
    if (series.books.length < 2) {
      console.log(`${progress} â­ï¸  ${series.name} (only ${series.books.length} book)`);
      skipped++;
      continue;
    }
    
    // Calculate year range
    const years = series.books.map(b => b.yearPublished).filter((y): y is number => y !== undefined);
    const yearStart = years.length > 0 ? Math.min(...years) : undefined;
    const yearEnd = years.length > 0 ? Math.max(...years) : undefined;
    
    // Save to database
    const seriesId = upsertSeries({
      name: series.name,
      author: series.author,
      total_books: series.books.length,
      year_start: yearStart,
      year_end: yearEnd,
      confidence: 0.8,
      isfdb_id: series.sourceId,
    });
    
    // Save each book
    for (const book of series.books) {
      upsertSeriesBook({
        series_id: seriesId,
        title: book.title,
        position: book.position,
        author: book.author,
        year_published: book.yearPublished,
        confidence: 0.8,
      });
    }
    
    // Store raw source data
    storeSourceData(seriesId, 'isfdb', result.raw, series.books.length);
    
    console.log(`${progress} âœ… ${series.name} - ${series.books.length} books`);
    saved++;
  }
  
  console.log('');
  console.log('â”€'.repeat(50));
  console.log('ğŸ“Š Discovery Summary:');
  console.log(`  Mode: ${mode}`);
  console.log(`  Discovered: ${discoveredSeries.length} series`);
  console.log(`  Saved: ${saved}`);
  console.log(`  Skipped: ${skipped}`);
  console.log(`  Errors: ${errors}`);
}
